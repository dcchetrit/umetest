import { db } from '@ume/shared';
import { 
  collection, 
  doc, 
  getDoc, 
  getDocs, 
  setDoc, 
  updateDoc, 
  query, 
  where, 
  orderBy, 
  runTransaction,
  onSnapshot,
  deleteDoc
} from 'firebase/firestore';

export interface BudgetTaskSync {
  budgetExpenseId: string;
  taskId: string;
  coupleId: string;
  syncType: 'payment_reminder' | 'deposit_due' | 'final_payment';
  createdAt: Date;
  isActive: boolean;
}

export interface PaymentReminderTask {
  id: string;
  title: string;
  description: string;
  status: 'not-started' | 'in-progress' | 'completed';
  priority: 'low' | 'medium' | 'high';
  category: string;
  dueDate: string;
  vendorName: string;
  amount: number;
  paymentType: 'deposit' | 'partial' | 'final';
  budgetExpenseId: string;
  createdAt: string;
  updatedAt: string;
  isAutoGenerated: boolean;
}

export interface BudgetExpenseForTask {
  id: string;
  vendorName: string;
  quotedPrice: number;
  amountPaid: number;
  paymentDueDate: Date | null;
  paymentStatus: 'paid' | 'due' | 'overdue' | 'partial';
  categoryId: string;
  depositAmount?: number;
  depositDueDate?: Date;
  finalPaymentDueDate?: Date;
}

export class BudgetTasksService {
  constructor(private coupleId: string) {}

  async syncPaymentReminders(): Promise<void> {
    try {
      await runTransaction(db, async (transaction) => {
        const budgetExpenses = await this.getBudgetExpensesWithPayments();
        const existingTasks = await this.getPaymentReminderTasks();
        const existingSyncs = await this.getBudgetTaskSyncs();

        for (const expense of budgetExpenses) {
          await this.processExpensePaymentReminders(
            expense, 
            existingTasks, 
            existingSyncs,
            transaction
          );
        }

        await this.cleanupCompletedPayments(existingTasks, budgetExpenses, transaction);
      });
    } catch (error) {
      console.error('Error syncing payment reminders:', error);
      throw error;
    }
  }

  private async getBudgetExpensesWithPayments(): Promise<BudgetExpenseForTask[]> {
    const expensesQuery = query(collection(db, 'couples', this.coupleId, 'budget', 'expenses', 'items'));
    const expensesSnapshot = await getDocs(expensesQuery);
    
    const expenses: BudgetExpenseForTask[] = [];
    
    for (const expenseDoc of expensesSnapshot.docs) {
      const expenseData = expenseDoc.data();
      
      if (expenseData.paymentDueDate || expenseData.depositDueDate || expenseData.finalPaymentDueDate) {
        const expense: BudgetExpenseForTask = {
          id: expenseDoc.id,
          vendorName: expenseData.vendorName,
          quotedPrice: expenseData.quotedPrice || 0,
          amountPaid: expenseData.amountPaid || 0,
          paymentDueDate: expenseData.paymentDueDate?.toDate?.() || (expenseData.paymentDueDate ? new Date(expenseData.paymentDueDate.seconds * 1000) : null),
          depositDueDate: expenseData.depositDueDate?.toDate?.() || (expenseData.depositDueDate ? new Date(expenseData.depositDueDate.seconds * 1000) : null),
          finalPaymentDueDate: expenseData.finalPaymentDueDate?.toDate?.() || (expenseData.finalPaymentDueDate ? new Date(expenseData.finalPaymentDueDate.seconds * 1000) : null),
          depositAmount: expenseData.depositAmount,
          paymentStatus: expenseData.paymentStatus || 'due',
          categoryId: expenseData.categoryId || 'unknown'
        };
        
        expenses.push(expense);
      }
    }
    
    return expenses;
  }

  private async getPaymentReminderTasks(): Promise<PaymentReminderTask[]> {
    const tasksQuery = query(
      collection(db, 'couples', this.coupleId, 'tasks'),
      where('isAutoGenerated', '==', true)
    );
    const tasksSnapshot = await getDocs(tasksQuery);
    
    return tasksSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as PaymentReminderTask[];
  }

  private async getBudgetTaskSyncs(): Promise<BudgetTaskSync[]> {
    const syncsQuery = query(
      collection(db, 'couples', this.coupleId, 'budgetTaskSyncs'),
      where('isActive', '==', true)
    );
    const syncsSnapshot = await getDocs(syncsQuery);
    
    return syncsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate() || new Date()
    })) as BudgetTaskSync[];
  }

  private async processExpensePaymentReminders(
    expense: BudgetExpenseForTask,
    existingTasks: PaymentReminderTask[],
    existingSyncs: BudgetTaskSync[],
    transaction: any
  ): Promise<void> {

    const today = new Date();
    const reminderLeadDays = 7; // Create reminders 7 days before due date

    // Handle deposit payment reminder
    if (expense.depositDueDate && expense.depositAmount) {
      if (!this.hasExistingSync(expense.id, 'deposit_due', existingSyncs)) {
        await this.createPaymentReminderTask(
          expense, 
          'deposit_due', 
          expense.depositDueDate,
          expense.depositAmount || 0,
          transaction
        );
      }
    }

    // Handle final payment reminder
    if (expense.finalPaymentDueDate) {
      const remainingAmount = expense.quotedPrice - expense.amountPaid;
      if (remainingAmount > 0 && !this.hasExistingSync(expense.id, 'final_payment', existingSyncs)) {
        await this.createPaymentReminderTask(
          expense,
          'final_payment',
          expense.finalPaymentDueDate,
          remainingAmount,
          transaction
        );
      }
    }

    // Handle general payment reminder
    if (expense.paymentDueDate && expense.paymentStatus !== 'paid') {
      const remainingAmount = expense.quotedPrice - expense.amountPaid;
      if (remainingAmount > 0 && !this.hasExistingSync(expense.id, 'payment_reminder', existingSyncs)) {
        await this.createPaymentReminderTask(
          expense,
          'payment_reminder',
          expense.paymentDueDate,
          remainingAmount,
          transaction
        );
      }
    }
  }

  private hasExistingSync(
    expenseId: string, 
    syncType: BudgetTaskSync['syncType'], 
    syncs: BudgetTaskSync[]
  ): boolean {
    return syncs.some(sync => 
      sync.budgetExpenseId === expenseId && 
      sync.syncType === syncType && 
      sync.isActive
    );
  }

  private async createPaymentReminderTask(
    expense: BudgetExpenseForTask,
    syncType: BudgetTaskSync['syncType'],
    dueDate: Date,
    amount: number,
    transaction: any
  ): Promise<void> {
    const taskId = `payment-${expense.id}-${syncType}-${Date.now()}`;
    const syncId = `sync-${expense.id}-${syncType}`;


    const taskTitle = this.generateTaskTitle(expense.vendorName, syncType, amount);
    const taskDescription = this.generateTaskDescription(expense, syncType, amount);
    const priority = this.determinePriority(dueDate, amount);
    const category = this.mapCategoryToTaskCategory(expense.categoryId);

    const task: PaymentReminderTask = {
      id: taskId,
      title: taskTitle,
      description: taskDescription,
      status: 'not-started',
      priority,
      category,
      dueDate: dueDate.toISOString().split('T')[0],
      vendorName: expense.vendorName,
      amount,
      paymentType: syncType === 'deposit_due' ? 'deposit' : 
                  syncType === 'final_payment' ? 'final' : 'partial',
      budgetExpenseId: expense.id,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isAutoGenerated: true
    };

    const sync: BudgetTaskSync = {
      budgetExpenseId: expense.id,
      taskId,
      coupleId: this.coupleId,
      syncType,
      createdAt: new Date(),
      isActive: true
    };

    // Create task and sync record
    transaction.set(doc(db, 'couples', this.coupleId, 'tasks', taskId), task);
    transaction.set(doc(db, 'couples', this.coupleId, 'budgetTaskSyncs', syncId), sync);
  }

  private generateTaskTitle(vendorName: string, syncType: string, amount: number): string {
    const formattedAmount = `$${amount.toLocaleString()}`;
    
    switch (syncType) {
      case 'deposit_due':
        return `Pay deposit to ${vendorName} (${formattedAmount})`;
      case 'final_payment':
        return `Final payment to ${vendorName} (${formattedAmount})`;
      case 'payment_reminder':
        return `Payment due to ${vendorName} (${formattedAmount})`;
      default:
        return `Payment to ${vendorName} (${formattedAmount})`;
    }
  }

  private generateTaskDescription(
    expense: BudgetExpenseForTask, 
    syncType: string, 
    amount: number
  ): string {
    const total = expense.quotedPrice;
    const paid = expense.amountPaid;
    const remaining = total - paid;

    switch (syncType) {
      case 'deposit_due':
        return `Deposit payment is due for ${expense.vendorName}. Amount: $${amount.toLocaleString()}. This secures your booking and is part of the total quoted price of $${total.toLocaleString()}.`;
      case 'final_payment':
        return `Final payment is due for ${expense.vendorName}. Amount: $${amount.toLocaleString()}. You've already paid $${paid.toLocaleString()} of the total $${total.toLocaleString()}.`;
      case 'payment_reminder':
        return `Payment is due for ${expense.vendorName}. Amount: $${amount.toLocaleString()}. Remaining balance: $${remaining.toLocaleString()} of total $${total.toLocaleString()}.`;
      default:
        return `Payment reminder for ${expense.vendorName} - $${amount.toLocaleString()}`;
    }
  }

  private determinePriority(dueDate: Date, amount: number): 'low' | 'medium' | 'high' {
    const today = new Date();
    const daysUntilDue = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    
    if (daysUntilDue <= 3) return 'high';
    if (daysUntilDue <= 7) return 'medium';
    if (amount > 5000) return 'high';
    if (amount > 1000) return 'medium';
    return 'low';
  }

  private mapCategoryToTaskCategory(budgetCategory: string): string {
    const categoryMap: Record<string, string> = {
      'venue': 'venue',
      'catering': 'catering',
      'photography': 'photography',
      'music': 'music',
      'flowers': 'flowers',
      'attire': 'attire',
      'stationery': 'invitations',
      'transportation': 'transportation',
      'other': 'other'
    };

    return categoryMap[budgetCategory] || 'other';
  }

  private async cleanupCompletedPayments(
    existingTasks: PaymentReminderTask[],
    budgetExpenses: BudgetExpenseForTask[],
    transaction: any
  ): Promise<void> {
    for (const task of existingTasks) {
      const correspondingExpense = budgetExpenses.find(e => e.id === task.budgetExpenseId);
      
      // If expense is fully paid or task is completed, mark sync as inactive
      if (!correspondingExpense || correspondingExpense.paymentStatus === 'paid' || task.status === 'completed') {
        const syncQuery = query(
          collection(db, 'couples', this.coupleId, 'budgetTaskSyncs'),
          where('taskId', '==', task.id),
          where('isActive', '==', true)
        );
        const syncSnapshot = await getDocs(syncQuery);
        
        syncSnapshot.docs.forEach(syncDoc => {
          transaction.update(syncDoc.ref, { isActive: false });
        });

        // Optionally mark the task as completed if payment is done
        if (correspondingExpense?.paymentStatus === 'paid' && task.status !== 'completed') {
          transaction.update(doc(db, 'couples', this.coupleId, 'tasks', task.id), {
            status: 'completed',
            updatedAt: new Date().toISOString()
          });
        }
      }
    }
  }

  // Handle task completion -> budget update
  async handleTaskCompletion(taskId: string): Promise<void> {
    try {
      await runTransaction(db, async (transaction) => {
        const taskDoc = await transaction.get(doc(db, 'couples', this.coupleId, 'tasks', taskId));
        if (!taskDoc.exists()) return;

        const task = taskDoc.data() as PaymentReminderTask;
        if (!task.isAutoGenerated || task.status === 'completed') return;

        // Find corresponding budget expense
        const syncQuery = query(
          collection(db, 'couples', this.coupleId, 'budgetTaskSyncs'),
          where('taskId', '==', taskId),
          where('isActive', '==', true)
        );
        const syncSnapshot = await getDocs(syncQuery);
        
        if (syncSnapshot.empty) return;

        const sync = syncSnapshot.docs[0].data() as BudgetTaskSync;
        
        // Update budget expense payment status
        await this.updateBudgetExpensePayment(sync.budgetExpenseId, task, transaction);
        
        // Mark task as completed
        transaction.update(taskDoc.ref, {
          status: 'completed',
          updatedAt: new Date().toISOString()
        });

        // Deactivate sync
        transaction.update(syncSnapshot.docs[0].ref, { isActive: false });
      });
    } catch (error) {
      console.error('Error handling task completion:', error);
      throw error;
    }
  }

  private async updateBudgetExpensePayment(
    expenseId: string, 
    task: PaymentReminderTask, 
    transaction: any
  ): Promise<void> {
    // Find the budget category containing this expense
    const categoryQuery = query(collection(db, 'couples', this.coupleId, 'budgetCategories'));
    const categorySnapshot = await getDocs(categoryQuery);
    
    for (const categoryDoc of categorySnapshot.docs) {
      const categoryData = categoryDoc.data();
      const expenses = categoryData.expenses || [];
      
      const expenseIndex = expenses.findIndex((e: any) => e.id === expenseId);
      if (expenseIndex !== -1) {
        const expense = expenses[expenseIndex];
        
        // Update payment amount
        expense.amountPaid = (expense.amountPaid || 0) + task.amount;
        
        // Update payment status
        if (expense.amountPaid >= expense.quotedPrice) {
          expense.paymentStatus = 'paid';
        } else {
          expense.paymentStatus = 'partial';
        }
        
        expense.updatedAt = new Date();
        
        // Update the category document
        transaction.update(categoryDoc.ref, {
          expenses,
          updatedAt: new Date()
        });
        
        break;
      }
    }
  }

  // Get payment reminder statistics for dashboard
  async getPaymentReminderStats(): Promise<{
    totalReminders: number;
    upcomingPayments: number;
    overduePayments: number;
    completedPayments: number;
    totalAmountDue: number;
  }> {
    try {
      const tasks = await this.getPaymentReminderTasks();
      const today = new Date();
      
      let upcomingPayments = 0;
      let overduePayments = 0;
      let completedPayments = 0;
      let totalAmountDue = 0;
      
      tasks.forEach(task => {
        const dueDate = new Date(task.dueDate);
        
        if (task.status === 'completed') {
          completedPayments++;
        } else {
          totalAmountDue += task.amount;
          
          if (dueDate < today) {
            overduePayments++;
          } else {
            upcomingPayments++;
          }
        }
      });
      
      return {
        totalReminders: tasks.length,
        upcomingPayments,
        overduePayments,
        completedPayments,
        totalAmountDue
      };
    } catch (error) {
      console.error('Error getting payment reminder stats:', error);
      return {
        totalReminders: 0,
        upcomingPayments: 0,
        overduePayments: 0,
        completedPayments: 0,
        totalAmountDue: 0
      };
    }
  }

  // Real-time listener for budget changes
  subscribeToPaymentReminders(callback: (stats: any) => void): () => void {
    const unsubscribes: (() => void)[] = [];
    
    // Listen to budget categories changes
    const budgetUnsubscribe = onSnapshot(
      collection(db, 'couples', this.coupleId, 'budgetCategories'),
      () => {
        this.syncPaymentReminders().then(() => {
          this.getPaymentReminderStats().then(callback);
        });
      }
    );
    unsubscribes.push(budgetUnsubscribe);
    
    // Listen to task changes
    const tasksUnsubscribe = onSnapshot(
      query(
        collection(db, 'couples', this.coupleId, 'tasks'),
        where('isAutoGenerated', '==', true)
      ),
      () => {
        this.getPaymentReminderStats().then(callback);
      }
    );
    unsubscribes.push(tasksUnsubscribe);
    
    return () => {
      unsubscribes.forEach(unsubscribe => unsubscribe());
    };
  }
}

// Factory function for creating service instances
export function createBudgetTasksService(coupleId: string): BudgetTasksService {
  return new BudgetTasksService(coupleId);
}

// Utility function to initialize payment reminders for a couple
export async function initializePaymentReminders(coupleId: string): Promise<void> {
  const service = createBudgetTasksService(coupleId);
  await service.syncPaymentReminders();
}